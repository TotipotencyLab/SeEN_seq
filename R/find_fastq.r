# Roxygen2 style documentation - autogenerated by GitHub co-pilot
# -------------------------------------------------------------------------------------------------
#' Find and Assign FASTQ Files to Sample Data Frame
#'
#' This function searches for FASTQ files in a specified directory and assigns them to a given data frame 
#' based on a prefix match. It supports paired-end (R1/R2) and single-end (SE) FASTQ files, and can handle 
#' unknown or unmatched files.
#'
#' @param sample_df A data frame with at least one column named \code{fastq_prefix}, which contains the 
#'   prefixes used to match FASTQ files.
#' @param fastq_dir A character string specifying the path to the directory where FASTQ files are located.
#' @param quiet A logical value. If \code{TRUE}, suppresses warning messages about unmatched or unknown files.
#'   Defaults to \code{FALSE}.
#' @param keep_NA_col A logical value. If \code{TRUE}, retains newly created columns with all \code{NA} values 
#'   in the output data frame. Defaults to \code{FALSE}.
#'
#' @return A data frame with additional columns for detected FASTQ files:
#'   \itemize{
#'     \item \code{fastq_R1}: File paths for R1 paired-end FASTQ files.
#'     \item \code{fastq_R2}: File paths for R2 paired-end FASTQ files.
#'     \item \code{fastq_SE}: File paths for single-end FASTQ files.
#'     \item \code{fastq_unknown}: File paths for unmatched or unknown FASTQ files.
#'   }
#'   If \code{keep_NA_col} is \code{FALSE}, columns with all \code{NA} values are removed.
#'
#' @details
#' The function uses the \code{fastq_prefix} column in \code{sample_df} to match file names in the specified 
#' directory. It identifies paired-end files based on the presence of "R1" and "R2" patterns in the file names. 
#' Any unmatched or unknown files are recorded in the \code{fastq_unknown} column.
#'
#' Warnings are issued for samples that are not found in the directory or have unknown FASTQ files associated 
#' with them, unless \code{quiet = TRUE}.
#'
#' @examples
#' \dontrun{
#' # Example usage:
#' sample_df <- data.frame(fastq_prefix = c("sample1", "sample2"))
#' fastq_dir <- "/path/to/fastq/files"
#' result <- find_fastq(sample_df, fastq_dir, quiet = FALSE, keep_NA_col = FALSE)
#' print(result)
#' }
#'
#' @importFrom tibble as_tibble
#' @importFrom dplyr mutate
#' @export

# /////////////////////////////////////////////////////////////////////////////////////////////////
#region find_fastq
# /////////////////////////////////////////////////////////////////////////////////////////////////

find_fastq <- function(sample_df, fastq_dir, quiet = FALSE, keep_NA_col = FALSE) {
  require(tibble)
  require(dplyr)
  require(stringr)
  # Description:
  #   This function will look for fastq files in the specified directory and assign them to the sample_df
  # input:
  #   sample_df: <data frame>: with at least twos columns 
  #     sample: <character>: sample name
  #     fastq_prefix: <character>: prefix of fastq files
  #   fastq_dir: <character>: lenght of 1; path to directory where fastq files are located
  #   quiet: <logical>: if TRUE, suppress warning messages
  #   keep_NA_col: <logical>: if TRUE, keep newly created columns with all NA values
  # output:
  #   sample_df: <data frame>: with additional columns for detected fastq files

  sample_df <- as_tibble(sample_df)
  sample_df <- mutate(sample_df, fastq_R1 = NA, fastq_R2 = NA, fastq_SE = NA, fastq_unknown = NA)

  fastq_ext_regex <- "((\\.fq)|(\\.fastq))(\\.gz)?$"
  f <- list.files(fastq_dir, recursive = TRUE, full.name = TRUE, pattern = fastq_ext_regex)
  # placeholder: keep row index of strange sample-fastq mappping
  unfound_sample <- integer()
  unknown_sample <- integer()
  for (i in seq_along(sample_df$fastq_prefix)) {
    # TODO: implement both startsWith and grepl (i.e., fastq_prefix is regex)
    f_hit <- base::startsWith(basename(f), sample_df$fastq_prefix[i])
    if (any(f_hit)) {
      # assign found fastq files to the sample_df
      fq_hit <- f[f_hit]
      if (length(f[f_hit]) == 1) {
        sample_df$fastq_SE[i] <- fq_hit
      } else {
        # Check whether it has R1 and R2 pattern
        R1_hit_idx <- grep(basename(fq_hit), pattern = paste0("[_.]R?1", fastq_ext_regex))
        R2_hit_idx <- grep(basename(fq_hit), pattern = paste0("[_.]R?2", fastq_ext_regex))
        # if they are not overlap, and each have only one hit
        if (length(intersect(R1_hit_idx, R2_hit_idx)) == 0 && length(R1_hit_idx) == 1 && length(R2_hit_idx) == 1) {
          sample_df$fastq_R1[i] <- fq_hit[R1_hit_idx]
          sample_df$fastq_R2[i] <- fq_hit[R2_hit_idx]
          fq_hit <- fq_hit[-unique(c(R1_hit_idx, R2_hit_idx))] # Removed from the current hit
        }

        # If there are still some left, assign them to fastq_unknown
        if (length(fq_hit) > 0) {
          sample_df$fastq_unknown[i] <- paste0(fq_hit, collapse = "; ")
          unknown_sample <- c(unknown_sample, i)
        }
      }
    } else {
      unfound_sample <- c(unfound_sample, i)
    }
  }

  # Warning of strange sample-fastq mapping
  if (!quiet) {
    if(length(unfound_sample) == nrow(sample_df)) {
      warning(
        "Couldn't find any fastq files for all samples. Please check if the directory for the fastq files is correct.\n",
        "Received fastq directory: ", fastq_dir, "\n"
      )
    } else if (length(unfound_sample) > 0) {
      tmp_df <- sample_df[unfound_sample, , drop = FALSE]
      warning("Some samples are not found in fastq directory:\n", paste0(tmp_df$sample, "  -  ", tmp_df$fastq_prefix, collapse = "\n"))
    }
    if (length(unknown_sample) > 0) {
      tmp_df <- sample_df[unknown_sample, , drop = FALSE]
      warning("Some samples have unknown fastq files associated to them:\n", paste0(tmp_df$sample, "  -  ", tmp_df$fastq_prefix, collapse = "\n"))
    }
  }

  if (!keep_NA_col) {
    # Remove newly created columns (i.e., by this function) with all NA values
    all_na_col_idx <- sapply(sample_df, function(x) all(is.na(x)))
    target_col_idx <- colnames(sample_df) %in% c("fastq_R1", "fastq_R2", "fastq_SE", "fastq_unknown")
    sample_df <- sample_df[, !(all_na_col_idx & target_col_idx), drop = FALSE]
    # sample_df <- sample_df %>% select(where(~ any(!is.na(.))))
  }
  return(sample_df)
}

#region lib_layout
sample_df_add_lib_layout <- function(sample_df) {
  # Check library layout
  # Assuming that sample_df has mixed of paired and single-end fastq files
  proj_lib_layout <- c(single = FALSE, paired = FALSE)
  SE_cols <- "fastq_SE"
  PE_cols <- c("fastq_R1", "fastq_R2")

  PE_row_idx <- integer()
  if (all(PE_cols %in% colnames(sample_df))) {
    PE_row_idx <- which(rowSums(is.na(sample_df[, PE_cols])) == 0)
    if (length(PE_row_idx) > 0) proj_lib_layout["paired"] <- TRUE
  }
  SE_row_idx <- integer()
  if (all(SE_cols %in% colnames(sample_df))) {
    SE_row_idx <- which(rowSums(is.na(sample_df[, SE_cols])) == 0)
    if (length(SE_row_idx) > 0) proj_lib_layout["single"] <- TRUE
  }

  if(length(intersect(SE_row_idx, PE_row_idx)) > 0) {
    mixed_layout_idx <- intersect(SE_row_idx, PE_row_idx)
    tmp_df <- sample_df[mixed_layout_idx, , drop=FALSE]
    warning(
      "Some samples have both paired (PE) and single-end (SE) fastq files associated to them. The PE will take priority here.\nAffected samples:\n",
      paste0(tmp_df$sample, "  -  ", tmp_df$fastq_prefix, collapse = "\n")
    )
  }

  sample_df$lib_layout <- NA
  sample_df$lib_layout[SE_row_idx] <- "single"
  sample_df$lib_layout[PE_row_idx] <- "paired"

  return(sample_df)
}
